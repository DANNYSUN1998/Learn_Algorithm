# 动态规划

## 何为动态规划

动态规划适用于解决具有多重重叠子问题的问题，其本质思想史根据迁移状态来推导出当前状态。解决动态规划问题主要有以下几个重要的步骤：

1. 确定dp[]数组的定义（下标的定义）
2. 确定dp数组的状态推导公式。
3. 初始化dp数组以及遍历顺序。

主要难点在于前两个，尤其是如何把待解决的问题转换到DP思想上（如何确定DP数组下标的定义），例如[正则表达式](https://leetcode-cn.com/problems/regular-expression-matching/)和[编辑距离](https://leetcode-cn.com/problems/edit-distance/)两个问题，需要经过复杂的推导才能确定DP数组的状态推导函数。以下部分会着重的讲述我在学习DP的过程中遇到的难题以及具体的推导的方法。



### [343. 整数拆分](https://leetcode-cn.com/problems/integer-break/submissions/) 

题目描述：**给定一个正整数 *n*，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。**

第一步：定义dp数组。规定dp[i] 代表正整数i拆分后可以得到的最大乘积。

第二步：确定推导公式。直观上来看，dp[i] = max(dp[j] * dp[i-j])，j=1...i。在实现计算的过程中，我们使用两个for循环来计算：

```
int integerBreak(int n) {
        vector<int> dp(n + 1, 0);
        dp[1] = 1;
        dp[2] = 1;
        for(int i = 3; i <= n; i++)
        {
            for(int j = 0; j <= i;j++)
            {
                dp[i] = .....;
            }
        }
        return dp[n];
    }
```

使用这种方法计算时，**我们默认每一个dp[i]都是由至少两个dp[j]元素相乘得来，既每个dp[i]强制拆分成了至少4个数相乘，这样就忽略了两个数相乘和三个数相乘的情况**，因此，上述的dp推导公式是不正确的，正确的推导公式应该写成dp[i] = max(j * (i - j), j * dp[i-j]);这样就考虑了两个数相乘和三个数相乘的情况。

正确的代码应该写为：

```
class Solution {
public:
    int integerBreak(int n) {
        vector<int> dp(n + 1, 0);
        dp[1] = 1;
        dp[2] = 1;
        for(int i = 3; i <= n; i++)
        {
            for(int j = 0; j <= i;j++)
            {
                dp[i] = max(dp[i], max(j * dp[i-j], j * (i-j)));
            }
        }
        return dp[n];
    }
};
```



### [96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/submissions/)

题目描述：**给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。**

第一步：定义dp数组下标。对于一个有i个节点的二叉树，我们定义dp[i]为可能的二叉树的个数。

第二步：确定dp推导公式。对于一个固定节点个数的二叉树，其可能的形状的个数为左子树可能的形状个数乘以右子树可能的形状个数。左子树和右子树个数和为i-1，故推导公式为：
$$
d p[i] = \sum{dp[j] * dp[i - j - 1]}, j = 0,1,2,...,i-1
$$
正确的代码为：

```
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n+1, 0);
        dp[0] = 1;
        dp[1] = 1;
        for(int i = 2; i <= n; i++)
        {
            for(int j = 0; j < i; j++)
            {
                dp[i] += dp[j] * dp[i-j-1];
            }
        }
        return dp[n];
    }
};
```

## 0-1背包问题

问题描述：**有N件物品和一个最多能被重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。**

直观想法：用暴力的方法，写一个回溯法的解决方案，每一个物品对应取和不取两种操作。但是这样操作的时间复杂度太高，是O(2^n)。

DP解法

1. 定义dp数组以及下表的意义：

   使用dp[i] [j]代表从0-i的物品中去取物品放进背包大小为j的背包中可以得到的最大的收益。 

   ![截屏2021-10-11 下午7.57.54](算法总结.assets/截屏2021-10-11 下午7.57.54.png)

2. 确定递推公式

   对于dp[i] [j],如果取第i个物品，则dp[i] [j]由dp[i-1] [j - weight[i]]确定：
   $$
   dp[i][j] = dp[i-1][j - weight[i]] + value[i]
   $$
   如果不取：
   $$
   dp[i][j] = dp[i-1][j]
   $$
   得到这个递推的公式之后