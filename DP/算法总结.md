# 动态规划

## 何为动态规划

动态规划适用于解决具有多重重叠子问题的问题，其本质思想史根据迁移状态来推导出当前状态。解决动态规划问题主要有以下几个重要的步骤：

1. 确定dp[]数组的定义（下标的定义）
2. 确定dp数组的状态推导公式。
3. 初始化dp数组以及遍历顺序。

主要难点在于前两个，尤其是如何把待解决的问题转换到DP思想上（如何确定DP数组下标的定义），例如[正则表达式](https://leetcode-cn.com/problems/regular-expression-matching/)和[编辑距离](https://leetcode-cn.com/problems/edit-distance/)两个问题，需要经过复杂的推导才能确定DP数组的状态推导函数。以下部分会着重的讲述我在学习DP的过程中遇到的难题以及具体的推导的方法。



### [343. 整数拆分](https://leetcode-cn.com/problems/integer-break/submissions/) 

题目描述：**给定一个正整数 *n*，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。**

第一步：定义dp数组。规定dp[i] 代表正整数i拆分后可以得到的最大乘积。

第二步：确定推导公式。直观上来看，dp[i] = max(dp[j] * dp[i-j])，j=1...i。在实现计算的过程中，我们使用两个for循环来计算：

```
int integerBreak(int n) {
        vector<int> dp(n + 1, 0);
        dp[1] = 1;
        dp[2] = 1;
        for(int i = 3; i <= n; i++)
        {
            for(int j = 0; j <= i;j++)
            {
                dp[i] = .....;
            }
        }
        return dp[n];
    }
```

使用这种方法计算时，**我们默认每一个dp[i]都是由至少两个dp[j]元素相乘得来，既每个dp[i]强制拆分成了至少4个数相乘，这样就忽略了两个数相乘和三个数相乘的情况**，因此，上述的dp推导公式是不正确的，正确的推导公式应该写成dp[i] = max(j * (i - j), j * dp[i-j]);这样就考虑了两个数相乘和三个数相乘的情况。

正确的代码应该写为：

```
class Solution {
public:
    int integerBreak(int n) {
        vector<int> dp(n + 1, 0);
        dp[1] = 1;
        dp[2] = 1;
        for(int i = 3; i <= n; i++)
        {
            for(int j = 0; j <= i;j++)
            {
                dp[i] = max(dp[i], max(j * dp[i-j], j * (i-j)));
            }
        }
        return dp[n];
    }
};
```



### [96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/submissions/)

题目描述：**给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。**

第一步：定义dp数组下标定义